NumberMunchers
===

A twist of the classic NumberMunchers game, written in JavaScript/JSX using React and Redux


### Specifications
---

### Terms used
+ Hero: the movable main character, controlled by the Player
+ Player: you! But also a container called "Player" that handles input logic
+ GameBoard: where all UI exists in
+ Grid/GridCell: the cells (and groups of cells) that the hero can move on
+ Numbers: the "edible" numbers that possibly exist in each cell. Are central to the current rule
+ Rule: the current mathematical "rule" the player must abide to to win. Example: "Multiples of 4", "Prime numbers"

### Requirements

1. Grid
  1. Fixed size grid / rectangle (WxH cells)
  2. Cells can have a value in them or be empty
  3. Hero/monsters can walk on top of cells
2. Hero
  1. Hero will start at position (0,0) [future update: start at middle]
  2. Can move only one horizontal or vertical cell at a time (no diagonals), only limited by walls/extremes
  3. Can eat numbers when prompted to
  4. Starts game with XXX lives [incomplete]
  5. Loses a life on contact with monster or when eating a incorrect option [incomplete]
3. Player
  1. Selects moves for hero (move directions and "eat")
4. Numbers
  1. Used to fill up cells. Number generation follows a set of pre-defined rules
  2. Guarantee a 50%+ number of correct options
5. Levels
  1. Every level has a mathematical proposition (e.g. Multiples of 5, Equals 5, Prime numbers)
  2. Start with every grid cell populated by a generated number, possibly a correct answer
  <!---
      - Level ends when hero eats all correct answers
  --->
+ Monsters (in future version!)
  <!--
  1. Monsters enter level at some moment
    - On touching hero, monster kills him
    - Only move one space at a time (periodic moves)
  -->


### Parameters

1. Grid
  1. Grid is composed on multiple individual cell components *GridCell*s. The cells are contained in a higher order component called *Grid*, placed inside *GameBoard*. Cells are shaped as squares
  2. Each cell component can hold a value/text, passed in as a parameter. If null, considered an empty cell (can be emptied under conditions e.g. hero eating number)
  3. Cells are dumb components that can be "walked" upon. This is done transparently, without knowledge of the cell component (i.e. hero moves on top of cells and is not contained in them)
2. Hero
  1. Get grid cell at centralized position and place hero initially
  2. Update hero position with -1/+1 position index per move command, not allowing diagonal moves (and possibly delaying move inputs). Movements are made by the *Player* container
  3. Enter/space keyboard input prompts hero to eat option/value
  4. Life count held in app state
  5. When eating an option, check for *correct* field. If false, remove a life
    1. Not accounting for monster kills yet since monsters don't exist
3. Player
  1. Players moves based on reading the keyboard inputs and passing the moves to the interessed components
4. Numbers
  1. Values are generated by a dedicated class. Current possible value rules are:
    + Prime Numbers
    + Multiples
    + Sum expressions
  2. Will always have number of correct options in range 50% + (5 to 15%) --> [55 to 65]% of # of cells


### Roadmap
---

+ Hero life count
+ Monsters
+ Selectable rules
+ High score
